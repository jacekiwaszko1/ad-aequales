<!DOCTYPE html>
<title>Compositions ad aequales in the Music Collections of Wawel Cathedral</title>
<style>
body {
font-family: Arial, sans-serif;
padding: 20px;
}
.table-container {
width: 100%;
overflow-x: auto;
border: 1px solid #ccc;
padding: 10px;
}
table {
border-collapse: collapse;
min-width: 1200px;
}
th, td {
border: 1px solid #ddd;
padding: 8px;
white-space: nowrap;
}
th {
background: #f2f2f2;
position: sticky;
top: 0;
}
th button {
margin-left: 6px;
padding: 2px 5px;
font-size: 12px;
}
</style>
</head>
<body>
<h1>Compositions <i>ad aequales</i> in the Music Collections of Wawel Cathedral: A Digital Approach to Repertoire Extraction</h1>
<h2>Jacek Iwaszko</h2>
<h3>The dataset</h3>
<p>This repository contains the dataset used as the basis for the analytical study of ad aequales compositions preserved in the music collections of Wawel Cathedral. The source corpus consists of more than 2,000 works included in the digital editions published through the <a href="https://polishscores.org" target="_blank">Polish Digital Scores portal</a>. For the purposes of the present study, the corpus was narrowed to 884 complete four-voice compositions, counting each movement of a mass cycle as an independent item. Limiting the dataset to fully preserved four-part settings was essential, as incomplete materials would have prevented the application of several analytical procedures and could have obscured the interpretation of their outcomes.</p>
<div class="table-container">
<table id="data-table"></table>
</div>


<script>
document.addEventListener("DOMContentLoaded", () => {
  const tsvUrl = "https://raw.githubusercontent.com/jacekiwaszko1/ad-aequales-dataset/refs/heads/main/ad-eaquales-dataset.tsv";

  const table = document.getElementById("data-table");
  let originalData = []; // pełne dane (łącznie z nagłówkiem)
  let currentData = [];  // dane aktualnie wyświetlane (łącznie z nagłówkiem)
  let currentFilter = "ALL";

  // przechowuje kolumnę i kierunek ostatniego sortowania
  const sortState = { col: null, dir: "asc" };

  // --- Load TSV ---
  async function loadTSV(url) {
    const response = await fetch(url);
    const text = await response.text();
    const rows = text.trim().split("\n").map(r => r.split("\t"));
    return rows;
  }

  // --- Apply filter ---
  function applyFilter(filterValue) {
    currentFilter = filterValue;
    if (filterValue === "ALL") {
      currentData = [...originalData];
    } else {
      // zachowujemy nagłówek (originalData[0])
      currentData = [originalData[0], ...originalData.slice(1).filter(row => (row[row.length - 1] || "") === filterValue)];
    }
    // po filtrze zachowujemy ostatnie sortowanie jeśli istniało
    if (sortState.col !== null) {
      sortTable(sortState.col, /*toggle=*/ false);
    } else {
      renderTable();
    }
  }

  // --- Sort table (colIndex) ---
  // toggle param (domyślnie true) -> czy zmieniać kierunek sortowania względem poprzedniego stanu
  function sortTable(colIndex, toggle = true) {
    // toggle kierunku tylko jeśli klikamy tę samą kolumnę
    if (toggle && sortState.col === colIndex) {
      sortState.dir = sortState.dir === "asc" ? "desc" : "asc";
    } else {
      sortState.col = colIndex;
      sortState.dir = "asc";
    }

    // sortujemy wiersze bez nagłówka
    const bodyRows = currentData.slice(1);

    bodyRows.sort((rowA, rowB, idxA = 0, idxB = 0) => {
      const Araw = (rowA[colIndex] !== undefined && rowA[colIndex] !== null) ? String(rowA[colIndex]).trim() : "";
      const Braw = (rowB[colIndex] !== undefined && rowB[colIndex] !== null) ? String(rowB[colIndex]).trim() : "";

      // próba parsowania liczby (zamieniamy przecinek na kropkę)
      const numA = parseFloat(Araw.replace(",", "."));
      const numB = parseFloat(Braw.replace(",", "."));
      const bothNumeric = Araw !== "" && Braw !== "" && !isNaN(numA) && !isNaN(numB);

      let cmp = 0;
      if (bothNumeric) {
        cmp = numA - numB;
        if (cmp === 0) {
          // jeśli liczby równe, fallback do porównania tekstowego
          cmp = Araw.localeCompare(Braw, "pl", { sensitivity: "base" });
        }
      } else {
        cmp = Araw.localeCompare(Braw, "pl", { sensitivity: "base" });
      }

      return sortState.dir === "asc" ? cmp : -cmp;
    });

    // odbudowujemy currentData: nagłówek + posortowane wiersze
    currentData = [currentData[0], ...bodyRows];
    renderTable();
  }

  // --- Create header (z dropdownem w ostatniej kolumnie) ---
  function createHeader(headers) {
    const thead = document.createElement("thead");
    const tr = document.createElement("tr");

    headers.forEach((h, index) => {
      const th = document.createElement("th");

      // tytuł kolumny
      const title = document.createElement("span");
      title.textContent = h;
      th.appendChild(title);

      // przycisk sortowania
      const btn = document.createElement("button");
      btn.textContent = " ↕";
      btn.style.marginLeft = "6px";
      btn.onclick = () => sortTable(index, /*toggle=*/ true);
      th.appendChild(btn);

      // dropdown tylko w ostatniej kolumnie
      if (index === headers.length - 1) {
        const select = document.createElement("select");
        select.id = "filter-last-col";
        select.style.marginLeft = "8px";

        // wartości: ALL, R, R?, (empty) -- w danych empty to ""
        const options = [
          { v: "ALL", label: "ALL" },
          { v: "R\r", label: "R" },
          { v: "R?\r", label: "R?" },
          { v: "\r", label: "(empty)" }
        ];

        options.forEach(optDef => {
          const opt = document.createElement("option");
          opt.value = optDef.v;
          opt.textContent = optDef.label;
          select.appendChild(opt);
        });

        // ustaw aktualną wartość dropdownu
        select.value = currentFilter;
        select.onchange = (e) => applyFilter(e.target.value);
        th.appendChild(select);
      }

      tr.appendChild(th);
    });

    thead.appendChild(tr);
    return thead;
  }

  // --- Render table ---
  function renderTable() {
    table.innerHTML = "";
    if (!currentData || currentData.length === 0) return;

    const headers = originalData[0];
    table.appendChild(createHeader(headers));

    const tbody = document.createElement("tbody");
    currentData.slice(1).forEach(row => {
      const tr = document.createElement("tr");
      row.forEach(cell => {
        const td = document.createElement("td");
        td.textContent = cell;
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    // zsynchronizuj dropdown z currentFilter (na wypadek renderowania z zewnątrz)
    const select = document.getElementById("filter-last-col");
    if (select) select.value = currentFilter;
  }

  // --- Init ---
  loadTSV(tsvUrl).then(data => {
    originalData = data;
    currentData = [...originalData];
    renderTable();
  }).catch(err => {
    console.error("Błąd wczytywania TSV:", err);
  });
});
</script>


</body>
</html>
